# 项目实现方案：进程外UI架构

## 1. 项目概述与目标

### 背景
我们需要为AutoCAD插件开发一套现代化的用户界面（UI）。该插件需同时支持AutoCAD 2010（.NET Framework 3.5）和AutoCAD 2024（.NET Framework 4.8）。由于现代UI框架（如WPF的高级样式、WinUI 3）与.NET 3.5不兼容，传统的进程内UI方案无法满足需求。

### 目标
采用**进程外UI架构**，将UI作为一个独立的、使用现代.NET框架（如.NET 8）的应用程序。CAD插件通过进程间通信（IPC）与UI程序交互，从而实现：
*   **UI技术栈完全现代化**：不受CAD版本限制。
*   **核心业务逻辑100%复用**：继续沿用现有的多项目架构。
*   **高稳定性和隔离性**：UI崩溃不会导致CAD崩溃。

## 2. 核心架构原则

1.  **进程分离**：UI和CAD插件运行在两个独立的进程中。
2.  **关注点分离**：
    *   **UI进程**：仅负责界面展示和用户交互。
    *   **CAD插件进程**：负责业务逻辑、CAD API调用和与UI进程的通信协调。
3.  **标准化通信**：两个进程之间通过定义良好的、基于文本的协议进行通信，避免二进制依赖。
4.  **异步优先**：UI操作和CAD操作应尽可能异步进行，防止任一进程阻塞。

## 3. 技术栈与选型

| 组件 | 技术选型 | 理由 |
| :--- | :--- | :--- |
| **UI应用程序** | **WPF** | 强大的现代UI框架，支持MVVM模式，生态丰富。 |
| **UI目标框架** | **.NET 8** (或更高) | 最新LTS版本，性能优异，支持所有现代C#特性。 |
| **IPC机制** | **命名管道** | Windows原生支持，专为本地进程间通信设计，高效且可靠。 |
| **数据序列化** | **JSON** (`System.Text.Json`) | 轻量级、跨语言、人类可读，便于调试和扩展。 |
| **CAD插件** | 现有的C#/.NET Framework项目 | 保持现有架构不变，最小化改动。 |

## 4. 详细架构设计

### 4.1 项目结构

```
BlockManager/
├── BlockManager.Abstractions/          # 现有：抽象层
├── BlockManager.Core/                  # 现有：共享核心逻辑
├── BlockManager.Adapter.2010/          # 现有：AutoCAD 2010适配器
├── BlockManager.Adapter.2024/          # 现有：AutoCAD 2024适配器
├── BlockManager.UI/                    # 新增：WPF UI应用程序
│   ├── Views/                          # 视图层
│   ├── ViewModels/                     # 视图模型层
│   ├── Services/                       # UI服务层
│   └── Models/                         # UI数据模型
├── BlockManager.IPC/                   # 新增：IPC通信库
│   ├── Contracts/                      # 消息契约定义
│   ├── Client/                         # 客户端（UI进程）
│   └── Server/                         # 服务端（CAD进程）
└── BlockManager.Shared/                # 新增：共享数据模型
    └── DTOs/                           # 数据传输对象
```

### 4.2 进程架构图

```
┌─────────────────────┐         ┌─────────────────────┐
│   AutoCAD 进程      │         │    UI 进程          │
│                     │         │                     │
│ ┌─────────────────┐ │         │ ┌─────────────────┐ │
│ │ BlockManager    │ │         │ │ WPF Application │ │
│ │ Adapter         │ │         │ │ (.NET 8)        │ │
│ │ (.NET 3.5/4.8)  │ │         │ │                 │ │
│ └─────────────────┘ │         │ └─────────────────┘ │
│          │          │         │          │          │
│ ┌─────────────────┐ │         │ ┌─────────────────┐ │
│ │ IPC Server      │ │◄────────┤ │ IPC Client      │ │
│ │ (Named Pipes)   │ │         │ │ (Named Pipes)   │ │
│ └─────────────────┘ │         │ └─────────────────┘ │
└─────────────────────┘         └─────────────────────┘
```

## 5. IPC通信协议

### 5.1 消息格式

**基础消息结构**：
```json
{
  "messageId": "uuid",
  "messageType": "REQUEST|RESPONSE|EVENT",
  "action": "操作类型",
  "timestamp": "ISO8601时间戳",
  "data": { /* 数据载荷 */ },
  "error": { /* 错误信息（可选） */ }
}
```

### 5.2 核心消息类型

#### 文件系统操作
- `GET_BLOCK_LIBRARY_TREE` - 获取块库目录结构
- `GET_FILE_PREVIEW` - 获取文件预览
- `WATCH_FILE_CHANGES` - 监听文件变化

#### 块操作
- `INSERT_BLOCK` - 插入块到CAD
- `GET_BLOCK_INFO` - 获取块信息
- `VALIDATE_BLOCK` - 验证块文件

#### 生命周期管理
- `UI_READY` - UI进程就绪
- `CAD_SHUTDOWN` - CAD进程关闭
- `HEARTBEAT` - 心跳检测

## 6. 实现细节

### 6.1 UI层设计（WPF + MVVM）

**主要视图**：
- `MainWindow` - 主窗口
- `BlockLibraryView` - 块库浏览器
- `BlockPreviewView` - 块预览面板
- `SettingsView` - 设置界面

**视图模型**：
- `MainWindowViewModel` - 主窗口逻辑
- `BlockLibraryViewModel` - 块库管理
- `BlockItemViewModel` - 单个块项
- `PreviewViewModel` - 预览逻辑

### 6.2 IPC服务层

**CAD端（服务器）**：
```csharp
public interface IBlockManagerServer
{
    Task<TreeNodeDto> GetBlockLibraryTreeAsync(string rootPath);
    Task<PreviewDto> GetFilePreviewAsync(string filePath);
    Task<bool> InsertBlockAsync(InsertBlockRequest request);
}
```

**UI端（客户端）**：
```csharp
public interface IBlockManagerClient
{
    Task<TreeNodeDto> GetBlockLibraryTreeAsync(string rootPath);
    Task<PreviewDto> GetFilePreviewAsync(string filePath);
    Task<bool> InsertBlockAsync(InsertBlockRequest request);
    event EventHandler<FileChangedEventArgs> FileChanged;
}
```

### 6.3 数据传输对象（DTOs）

```csharp
public class TreeNodeDto
{
    public string Name { get; set; }
    public string Path { get; set; }
    public string Type { get; set; } // "folder" | "file"
    public List<TreeNodeDto> Children { get; set; }
    public FileInfoDto FileInfo { get; set; }
    public string IconType { get; set; } // "folder", "dwg", "image"
}

// 文件信息
public class FileInfoDto
{
    public string Name { get; set; }
    public string FullPath { get; set; }
    public string Extension { get; set; }
    public long Size { get; set; }
    public DateTime LastModified { get; set; }
    public bool HasPreview { get; set; }
    public string PreviewPath { get; set; } // DWG对应的PNG路径
}

// 预览数据
public class PreviewDto
{
    public string FilePath { get; set; }
    public string PreviewImageBase64 { get; set; }
    public FileInfoDto Metadata { get; set; }
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
}

// 文件变化事件
public class FileChangedEventArgs : EventArgs
{
    public string FilePath { get; set; }
    public string ChangeType { get; set; } // "Created", "Modified", "Deleted"
    public DateTime Timestamp { get; set; }
}

public class InsertBlockRequest
{
    public string BlockPath { get; set; }
    public Point3D InsertionPoint { get; set; }
    public Scale3D Scale { get; set; }
    public double Rotation { get; set; }
}
```

### 6.4 详细消息协议示例

#### 获取文件树
```json
// REQUEST
{
  "messageId": "req-001",
  "messageType": "REQUEST",
  "action": "GET_BLOCK_LIBRARY_TREE",
  "data": {
    "rootPath": "c:\\Users\\PC\\Desktop\\BlockManager\\BlockManager.Core\\Block"
  }
}

// RESPONSE
{
  "messageId": "req-001",
  "messageType": "RESPONSE",
  "action": "GET_BLOCK_LIBRARY_TREE",
  "data": {
    "tree": {
      "name": "块库 (Block Library)",
      "path": "c:\\Users\\PC\\Desktop\\BlockManager\\BlockManager.Core\\Block",
      "type": "folder",
      "iconType": "folder",
      "children": [
        {
          "name": "block1.dwg",
          "path": "c:\\...\\block1.dwg",
          "type": "file",
          "iconType": "dwg",
          "fileInfo": {
            "name": "block1.dwg",
            "fullPath": "c:\\...\\block1.dwg",
            "extension": ".dwg",
            "size": 2048,
            "lastModified": "2024-11-24T10:00:00Z",
            "hasPreview": true,
            "previewPath": "c:\\...\\block1.png"
          }
        }
      ]
    }
  }
}
```

#### 获取文件预览
```json
// REQUEST
{
  "messageId": "req-002",
  "messageType": "REQUEST",
  "action": "GET_FILE_PREVIEW",
  "data": {
    "filePath": "c:\\path\\to\\block.dwg"
  }
}

// RESPONSE
{
  "messageId": "req-002",
  "messageType": "RESPONSE",
  "action": "GET_FILE_PREVIEW",
  "data": {
    "filePath": "c:\\path\\to\\block.dwg",
    "previewImageBase64": "iVBORw0KGgoAAAANSUhEUgAA...",
    "metadata": {
      "name": "block.dwg",
      "fullPath": "c:\\path\\to\\block.dwg",
      "extension": ".dwg",
      "size": 2048,
      "lastModified": "2024-11-24T10:00:00Z",
      "hasPreview": true,
      "previewPath": "c:\\path\\to\\block.png"
    },
    "isSuccess": true,
    "errorMessage": null
  }
}
```

### 6.5 WPF界面设计

#### 主窗口布局（XAML）
```xml
<Window x:Class="BlockManager.UI.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="块库浏览器" Height="600" Width="800"
        MinHeight="400" MinWidth="600">
    
    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="350" MinWidth="250"/>
            <ColumnDefinition Width="5"/>
            <ColumnDefinition Width="*" MinWidth="300"/>
        </Grid.ColumnDefinitions>
        
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        
        <!-- 左侧：文件树 -->
        <TreeView Grid.Column="0" Name="FileTreeView"
                  ItemsSource="{Binding RootNode.Children}"
                  SelectedItemChanged="TreeView_SelectedItemChanged">
            <TreeView.ItemTemplate>
                <HierarchicalDataTemplate ItemsSource="{Binding Children}">
                    <StackPanel Orientation="Horizontal">
                        <Image Width="16" Height="16" 
                               Source="{Binding IconType, Converter={StaticResource IconConverter}}"/>
                        <TextBlock Text="{Binding Name}" Margin="5,0,0,0"/>
                    </StackPanel>
                </HierarchicalDataTemplate>
            </TreeView.ItemTemplate>
        </TreeView>
        
        <!-- 分隔条 -->
        <GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" 
                      Background="LightGray"/>
        
        <!-- 右侧：预览区域 -->
        <Grid Grid.Column="2">
            <Image Name="PreviewImage" Stretch="Uniform"
                   Source="{Binding CurrentPreview.PreviewImageBase64, Converter={StaticResource Base64ToImageConverter}}"
                   Visibility="{Binding CurrentPreview, Converter={StaticResource NullToVisibilityConverter}}"/>
            <TextBlock Text="选择文件查看预览" 
                       HorizontalAlignment="Center" VerticalAlignment="Center"
                       Visibility="{Binding CurrentPreview, Converter={StaticResource NullToVisibilityConverter}, ConverterParameter=Inverse}"/>
        </Grid>
        
        <!-- 底部状态栏 -->
        <StatusBar Grid.Row="1" Grid.ColumnSpan="3">
            <StatusBarItem Content="{Binding StatusText}"/>
        </StatusBar>
    </Grid>
</Window>
```

#### 主窗口ViewModel
```csharp
public class MainWindowViewModel : ViewModelBase
{
    private readonly IBlockManagerClient _client;
    private TreeNodeDto _rootNode;
    private TreeNodeDto _selectedNode;
    private PreviewDto _currentPreview;
    private string _statusText = "就绪";

    public TreeNodeDto RootNode
    {
        get => _rootNode;
        set => SetProperty(ref _rootNode, value);
    }

    public TreeNodeDto SelectedNode
    {
        get => _selectedNode;
        set
        {
            if (SetProperty(ref _selectedNode, value))
            {
                _ = LoadPreviewAsync(value);
            }
        }
    }

    public PreviewDto CurrentPreview
    {
        get => _currentPreview;
        set => SetProperty(ref _currentPreview, value);
    }

    public string StatusText
    {
        get => _statusText;
        set => SetProperty(ref _statusText, value);
    }

    public ICommand LoadLibraryCommand { get; }
    public ICommand FileDoubleClickCommand { get; }

    public MainWindowViewModel(IBlockManagerClient client)
    {
        _client = client;
        LoadLibraryCommand = new AsyncRelayCommand(LoadLibraryAsync);
        FileDoubleClickCommand = new AsyncRelayCommand<TreeNodeDto>(HandleFileDoubleClickAsync);
    }

    private async Task LoadLibraryAsync()
    {
        try
        {
            StatusText = "正在加载块库...";
            var rootPath = @"c:\Users\PC\Desktop\BlockManager\BlockManager.Core\Block";
            RootNode = await _client.GetBlockLibraryTreeAsync(rootPath);
            StatusText = $"已加载块库: {rootPath}";
        }
        catch (Exception ex)
        {
            StatusText = $"加载失败: {ex.Message}";
        }
    }

    private async Task LoadPreviewAsync(TreeNodeDto node)
    {
        if (node?.Type != "file") return;

        try
        {
            StatusText = $"正在加载预览: {node.Name}";
            CurrentPreview = await _client.GetFilePreviewAsync(node.Path);
            
            if (CurrentPreview.IsSuccess)
            {
                var fileInfo = CurrentPreview.Metadata;
                StatusText = $"文件: {fileInfo.Name} | 大小: {FormatFileSize(fileInfo.Size)}";
            }
            else
            {
                StatusText = $"预览加载失败: {CurrentPreview.ErrorMessage}";
            }
        }
        catch (Exception ex)
        {
            StatusText = $"预览加载错误: {ex.Message}";
        }
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}
```

## 7. 详细项目结构

### 7.1 新增项目结构
```
BlockManager.UI/                    # WPF应用程序 (.NET 8)
├── Views/
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│   └── Controls/
│       ├── FileTreeView.xaml
│       └── PreviewPanel.xaml
├── ViewModels/
│   ├── MainWindowViewModel.cs
│   ├── BlockLibraryViewModel.cs
│   └── Base/
│       ├── ViewModelBase.cs
│       └── AsyncRelayCommand.cs
├── Services/
│   ├── IBlockManagerClient.cs
│   └── BlockManagerClient.cs
├── Converters/
│   ├── IconConverter.cs
│   ├── Base64ToImageConverter.cs
│   └── NullToVisibilityConverter.cs
├── Models/
│   └── DTOs/
│       ├── TreeNodeDto.cs
│       ├── PreviewDto.cs
│       └── FileInfoDto.cs
├── Resources/
│   ├── Icons/
│   │   ├── folder.png
│   │   ├── dwg.png
│   │   └── image.png
│   └── Styles/
│       └── MainStyles.xaml
├── App.xaml
├── App.xaml.cs
└── BlockManager.UI.csproj

BlockManager.IPC/                   # IPC通信库 (.NET Standard 2.0)
├── Contracts/
│   ├── IBlockManagerServer.cs
│   ├── IBlockManagerClient.cs
│   └── Messages/
│       ├── MessageBase.cs
│       ├── RequestMessage.cs
│       └── ResponseMessage.cs
├── Client/
│   ├── NamedPipeClient.cs
│   └── BlockManagerClient.cs
├── Server/
│   ├── NamedPipeServer.cs
│   └── BlockManagerServer.cs
├── DTOs/
│   ├── TreeNodeDto.cs
│   ├── PreviewDto.cs
│   ├── FileInfoDto.cs
│   └── InsertBlockRequest.cs
├── Serialization/
│   └── JsonMessageSerializer.cs
└── BlockManager.IPC.csproj
```

### 7.2 现有项目集成
- **BlockManager.Adapter.2010** - 集成IPC服务器
- **BlockManager.Adapter.2024** - 集成IPC服务器
- **BlockManager.Core** - 保持现有逻辑，添加IPC支持

## 8. 实现步骤

### 阶段1：基础架构搭建
1. 创建新项目结构
2. 实现基础IPC通信框架
3. 定义消息协议和DTOs

### 阶段2：核心功能迁移
1. 将BlockLibraryViewer功能迁移到WPF
2. 实现文件系统操作的IPC接口
3. 集成现有的块操作逻辑

### 阶段3：高级功能
1. 实现文件监听和实时更新
2. 添加块预览和元数据显示
3. 优化性能和用户体验

### 阶段4：测试和部署
1. 单元测试和集成测试
2. 性能测试和稳定性测试
3. 部署脚本和安装程序

## 9. 核心技术实现细节

### 9.1 命名管道通信实现

#### 服务端（CAD进程）
```csharp
public class NamedPipeServer : IDisposable
{
    private readonly string _pipeName;
    private NamedPipeServerStream _pipeServer;
    private readonly CancellationTokenSource _cancellationTokenSource;

    public NamedPipeServer(string pipeName)
    {
        _pipeName = pipeName;
        _cancellationTokenSource = new CancellationTokenSource();
    }

    public async Task StartAsync()
    {
        _pipeServer = new NamedPipeServerStream(_pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Message);
        
        await _pipeServer.WaitForConnectionAsync(_cancellationTokenSource.Token);
        
        _ = Task.Run(async () => await HandleClientAsync(_cancellationTokenSource.Token));
    }

    private async Task HandleClientAsync(CancellationToken cancellationToken)
    {
        var buffer = new byte[4096];
        
        while (!cancellationToken.IsCancellationRequested && _pipeServer.IsConnected)
        {
            try
            {
                var bytesRead = await _pipeServer.ReadAsync(buffer, 0, buffer.Length, cancellationToken);
                if (bytesRead > 0)
                {
                    var message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                    var response = await ProcessMessageAsync(message);
                    
                    var responseBytes = Encoding.UTF8.GetBytes(response);
                    await _pipeServer.WriteAsync(responseBytes, 0, responseBytes.Length, cancellationToken);
                }
            }
            catch (Exception ex)
            {
                // 记录错误日志
                Console.WriteLine($"管道通信错误: {ex.Message}");
                break;
            }
        }
    }

    private async Task<string> ProcessMessageAsync(string message)
    {
        // 解析JSON消息并处理
        var request = JsonSerializer.Deserialize<RequestMessage>(message);
        
        switch (request.Action)
        {
            case "GET_BLOCK_LIBRARY_TREE":
                return await HandleGetBlockLibraryTreeAsync(request);
            case "GET_FILE_PREVIEW":
                return await HandleGetFilePreviewAsync(request);
            default:
                return CreateErrorResponse(request.MessageId, "Unknown action");
        }
    }
}
```

#### 客户端（UI进程）
```csharp
public class NamedPipeClient : IBlockManagerClient
{
    private readonly string _pipeName;
    private NamedPipeClientStream _pipeClient;

    public NamedPipeClient(string pipeName)
    {
        _pipeName = pipeName;
    }

    public async Task ConnectAsync()
    {
        _pipeClient = new NamedPipeClientStream(".", _pipeName, PipeDirection.InOut);
        await _pipeClient.ConnectAsync(5000); // 5秒超时
    }

    public async Task<TreeNodeDto> GetBlockLibraryTreeAsync(string rootPath)
    {
        var request = new RequestMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            Action = "GET_BLOCK_LIBRARY_TREE",
            Data = new { rootPath }
        };

        var response = await SendRequestAsync(request);
        return JsonSerializer.Deserialize<TreeNodeDto>(response.Data.ToString());
    }

    private async Task<ResponseMessage> SendRequestAsync(RequestMessage request)
    {
        var requestJson = JsonSerializer.Serialize(request);
        var requestBytes = Encoding.UTF8.GetBytes(requestJson);
        
        await _pipeClient.WriteAsync(requestBytes, 0, requestBytes.Length);
        
        var buffer = new byte[4096];
        var bytesRead = await _pipeClient.ReadAsync(buffer, 0, buffer.Length);
        
        var responseJson = Encoding.UTF8.GetString(buffer, 0, bytesRead);
        return JsonSerializer.Deserialize<ResponseMessage>(responseJson);
    }
}
```

### 9.2 WPF数据绑定和转换器

#### Base64图片转换器
```csharp
public class Base64ToImageConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string base64String && !string.IsNullOrEmpty(base64String))
        {
            try
            {
                var imageBytes = System.Convert.FromBase64String(base64String);
                using (var ms = new MemoryStream(imageBytes))
                {
                    var bitmap = new BitmapImage();
                    bitmap.BeginInit();
                    bitmap.CacheOption = BitmapCacheOption.OnLoad;
                    bitmap.StreamSource = ms;
                    bitmap.EndInit();
                    bitmap.Freeze();
                    return bitmap;
                }
            }
            catch
            {
                return null;
            }
        }
        return null;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

#### 图标转换器
```csharp
public class IconConverter : IValueConverter
{
    private static readonly Dictionary<string, BitmapImage> IconCache = new();

    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string iconType)
        {
            if (IconCache.TryGetValue(iconType, out var cachedIcon))
                return cachedIcon;

            var iconPath = iconType switch
            {
                "folder" => "pack://application:,,,/Resources/Icons/folder.png",
                "dwg" => "pack://application:,,,/Resources/Icons/dwg.png",
                "image" => "pack://application:,,,/Resources/Icons/image.png",
                _ => "pack://application:,,,/Resources/Icons/file.png"
            };

            var bitmap = new BitmapImage(new Uri(iconPath));
            IconCache[iconType] = bitmap;
            return bitmap;
        }
        return null;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

### 9.3 CAD端服务集成

#### 在现有Adapter中集成IPC服务
```csharp
// BlockManager.Adapter.2024/BlockLibraryCommands.cs
[CommandMethod("BLOCKVIEWER")]
public void ShowBlockViewer()
{
    try
    {
        // 启动IPC服务器（如果尚未启动）
        if (!_ipcServer.IsRunning)
        {
            await _ipcServer.StartAsync();
        }

        // 启动UI进程
        var uiProcessPath = Path.Combine(GetPluginDirectory(), "BlockManager.UI.exe");
        if (File.Exists(uiProcessPath))
        {
            Process.Start(uiProcessPath);
        }
        else
        {
            // 回退到原有的WinForms界面
            var viewer = new BlockLibraryViewer();
            viewer.Show();
        }
    }
    catch (Exception ex)
    {
        Application.ShowAlertDialog($"启动块库浏览器失败: {ex.Message}");
    }
}
```

## 10. 技术风险与应对

### 10.1 主要风险
- **IPC通信延迟**：可能影响用户体验
- **进程同步复杂性**：生命周期管理困难
- **调试复杂度**：跨进程调试困难
- **版本兼容性**：.NET Framework与.NET 8的兼容性问题

### 10.2 应对策略
- **性能优化**：使用异步操作、批量处理、缓存机制
- **健壮性设计**：心跳检测、自动重连、错误恢复
- **开发工具**：专用调试工具、日志系统、监控面板
- **向后兼容**：保留原有WinForms界面作为备选方案

## 11. 部署和维护

### 11.1 部署结构
```
安装目录/
├── BlockManager.UI.exe              # WPF UI应用程序 (.NET 8)
├── BlockManager.UI.dll
├── BlockManager.IPC.dll             # IPC通信库 (.NET Standard 2.0)
├── BlockManager.Adapter.2010.dll    # AutoCAD 2010插件
├── BlockManager.Adapter.2024.dll    # AutoCAD 2024插件
├── runtimes/                        # .NET 8运行时（如需要）
├── Resources/
│   └── Icons/                       # 界面图标资源
│       ├── folder.png
│       ├── dwg.png
│       └── image.png
└── config/                          # 配置文件
    ├── appsettings.json
    └── logging.json
```

### 11.2 配置管理
```json
// appsettings.json
{
  "BlockManager": {
    "UI": {
      "Theme": "Light",
      "WindowState": {
        "Width": 800,
        "Height": 600,
        "Left": 100,
        "Top": 100
      },
      "BlockLibraryPath": "c:\\Users\\PC\\Desktop\\BlockManager\\BlockManager.Core\\Block"
    },
    "IPC": {
      "PipeName": "BlockManager_IPC",
      "ConnectionTimeout": 5000,
      "RequestTimeout": 10000
    },
    "Logging": {
      "LogLevel": "Information",
      "LogPath": "logs/blockmanager.log"
    }
  }
}
```

### 11.3 安装和更新策略
1. **MSI安装包**：包含所有必要组件
2. **自动更新机制**：检测新版本并提示更新
3. **配置迁移**：升级时保留用户设置
4. **回滚机制**：出现问题时可回退到旧版本

## 12. 开发和测试计划

### 12.1 开发里程碑

#### 里程碑1：基础框架（2周）
- [ ] 创建项目结构
- [ ] 实现基础IPC通信
- [ ] 创建基础WPF界面框架
- [ ] 定义核心DTOs和接口

#### 里程碑2：核心功能（3周）
- [ ] 实现文件树加载和显示
- [ ] 实现图片预览功能
- [ ] 集成现有BlockLibraryViewer逻辑
- [ ] 实现基础的双击操作

#### 里程碑3：高级功能（2周）
- [ ] 添加文件监听和实时更新
- [ ] 优化性能和用户体验
- [ ] 实现错误处理和恢复机制
- [ ] 添加主题和样式支持

#### 里程碑4：测试和部署（1周）
- [ ] 单元测试和集成测试
- [ ] 性能测试
- [ ] 创建安装包和部署脚本
- [ ] 文档完善

### 12.2 测试策略

#### 单元测试
- IPC通信组件测试
- ViewModel逻辑测试
- 数据转换器测试
- 文件操作测试

#### 集成测试
- UI与CAD插件的完整交互测试
- 多版本AutoCAD兼容性测试
- 错误场景和恢复测试

#### 性能测试
- 大量文件加载性能测试
- IPC通信延迟测试
- 内存使用和泄漏测试

## 13. 总结

本实现方案通过进程外WPF应用的架构，成功解决了以下关键问题：

### 13.1 核心优势
1. **技术栈现代化**：UI使用.NET 8和WPF，不受CAD版本限制
2. **架构清晰**：进程分离，职责明确，便于维护和扩展
3. **向后兼容**：保留现有代码结构，最小化改动风险
4. **用户体验提升**：现代化界面，更好的交互体验

### 13.2 实施可行性
- **技术风险可控**：使用成熟的技术栈和设计模式
- **开发周期合理**：预估8周完成，分阶段实施
- **资源需求明确**：主要需要WPF和IPC开发经验

### 13.3 未来扩展性
- 可轻松添加新的CAD版本支持
- 可扩展更多块管理功能
- 可集成其他现代UI特性（如搜索、过滤、批量操作等）

这个方案为BlockManager项目的UI现代化提供了一个完整、可行的技术路径。